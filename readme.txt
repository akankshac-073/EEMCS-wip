====================================================
ENERGY-EFFICIENT MIXED-CRITICALITY SCHEDULER (EEMCS)
====================================================

=============
List of Files
=============

--------
.h files
--------

--> header.h: Contains all the ADT definitions and function declarations.

--------
.c files
--------

--> driver.c: File which contains main. Takes inputs and starts the simulation.
--> tasks.c: Contains task structure array preprocessing functions.
--> allocator.c: Contains all the functions related to the working of the criticality-aware offline task allocator. 
		A modified bin-packing scheme is followed -- low period tasks are first accomodated, followed by the remaining (high period tasks) using a criticality-aware WFD/FFD scheme. 
--> scheduler.c: Contains all the functions related to the working of the runtime scheduler. 
		The jobs of active tasks in each core are scheduled using partitioned EDF-VD and all the discarded jobs are scheduled globally in the slack time generated by these jobs. 
--> dp_slack.c: Contains all the functions related to the working of the dynamic procrastinator, slack calculator and discarded job scheduler.

---------------
.txt input file
---------------

input.txt: Contains the taskset input for which the scheduling algorithm is simulated.

The input file format is as follows:

<total number of tasks>
<total number of criticality levels>

In the following lines, enter parameters for each task in the taskset as follows:
<task phase>	<task period>	<task deadline>	<task criticality>	<wcet @ 1>	<wcet @ 2>   ...   <wcet @ task criticality>	 	 

----------------
.txt output file
----------------

-- NA -- [currently printing out the results to the terminal for verifiction]

--------
makefile
--------
 
Makefile: used to compile the code

==============
How to Compile
==============

--> Go to the path where the EEMCS folder is stored
--> Type 'make' or 'make all' in the terminal to compile the program

==============
How to Execute
==============

--> Compile the code as shown above
--> Type ./test in the terminal to execute the program

========================
Structure of the program
========================

--> The driver code starts fetches the input task parameters and begins the simulation.
--> The task preprocessing functions store the input parameters in a task structure array and sort it in decreasing order of criticality levels and utilizations (for offline task allocation).
--> The offline task allocator then sequentially allocates low-period tasks and high-period tasks to core using a criticality-aware WFD/FFD scheme while ensuring EDF-VD schedulability in each core.
--> The runtime scheduler loop then executes at every decision point for all cores. 
	--> The scheduling decision points include: 1. Arrival 2. Current job termination 3. Criticality level change due to wcet budget overrun at current level 4. Overrun 5. Core Wakeup
 	--> If the decision point is due to a job arrival: ready jobs (active/discarded) are added to their allocated core's run queue (active) or discarded queue (discarded). 
 	    If the core is not ACTIVE at the moment, add job to pending request queue.
 	--> If the decision point is due to job termination: 
 		--> If run queue is non-empty: schedule the next active job / calculate slack and try to accommodate the highest criticality discarded job.
 		--> If run queue is empty: calculate maximum possible slack time using dynamic procrastination and go for SHUTDOWN if enough slack is available, else go for DVFS (wip).
 	--> If the decision point is due to job exceeding its wcet budget: Update criticality level/ Update criticality mode and virtual deadlines.
 	--> If the decision point is due to job overrun: abort job, criticality level remains unchanged.
 	--> If the decision point is due to core waking up: reset core status and resume core execution by copying all jobs in pending request queue to the core's run queue. 
 	--> At every decision point, the scheduler schedules the next job / updates currently executing job's parameters, handles preemptions for all the active cores.

==================
Output of the Code
==================

--> Unformatted [currently printing out output SCHEDULE with debug prints]
